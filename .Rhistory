type = "Samples",
Export =  F
)
Meta$Pheno[Meta$Pheno=="#NA"] = NA
Meta$Pheno[Meta$Pheno=="NA"] = NA
Meta$Pheno[Meta$Pheno=="xx"] = NA
Meta$Pheno = Meta$Pheno[!is.na(Meta$Pheno$id_cit),]
Meta$Pheno= as.data.frame(Meta$Pheno)
rownames(Meta$Pheno) = Meta$Pheno$id_cit
Meta$Pheno = Meta$Pheno[Meta$Pheno$id_cit%in%colnames(Meta$Normalized.count.matrix),]
attributes(Meta)
CheckMeta(Meta)
str(Meta$Pheno)
Meta$Pheno = Charac.to.Num(Meta$Pheno)
str(Meta$Pheno)
LexicData(list.files.path, SC.Lexic = F, replaceLexic = T)
#' @param project project
#' @param ForceCleaning If TRUE, Force a cleaning method from Samples.clinical data into Patient.clinical data and vice versa.
#' @param force.replace set as F. T : replace an already object with the same name
#' @param all.col default F, if T, copy all column from clinic.
#' @importFrom utils menu
#' @import dplyr
#' @return a data frame of Samples pheno or patients clinical data. If Sample ID and Patients ID are the sames, so Samples.pheno and Patient_clinic are the same data frame
#' @export
#'
#' @examples "none"
CleaningClinic <- function(Metadata,
ClinicToClean = NULL,
name = NULL,
type = c("Samples", "Patients"),
list.files.path,
project,
ForceCleaning = F,
force.replace = F,
all.col = F){
#Force.Replace et detected si name déjà existant à faire.
if(is.null(ClinicToClean)){stop("ClinicToClean must be a character")}
if(!inherits(ClinicToClean,what ="character" )){ stop("ClinicToClean must be a character")}
if(is.null(name)){stop("Name must be a character")}
if(!inherits(name,what ="character" )){ stop("Name must be a character")}
if(!ClinicToClean%in%names(Metadata)) {stop(paste0(ClinicToClean,"is not in Metaobject")) }
if(!all(str_detect(names(Metadata),name)==F)){
message("An Object with the same name already exist in MetaObject")
if(force.replace==F){stop("set force.replace==T to subset object.")}}
if(type=="Samples"){
NBS <- which(attributes(Metadata)$Data.Type=="SamplesAnnot" & attributes(Metadata)$Export=="No")
if(ForceCleaning==F){
if(length(NBS)==0){stop("No SamplesAnnot found in Metadata object. Set ForceCleaning=T to force cleaning from Clinic")}
} else {  if(length(NBS)==0){NBS <- which(str_detect(attributes(Metadata)$Data.Type ,"Clinical.data") & attributes(Metadata)$Export=="No")    }}
if(NBS==which(names(Metadata)%in%ClinicToClean)){
clinic <- as.data.frame(Metadata[[NBS]])
if(all.col==T){
for (i in colnames(Metadata$Clinic)){
if (!i %in% names(SamplesLexic)){SamplesLexic <- AddKeyLexic(lexic = SamplesLexic, Param = c(i) ) }
}
LexicClinic=SamplesLexic
}else {  LexicClinic <- SamplesLexic }
clcl <-  data.frame(matrix(nrow = nrow(clinic), ncol = length(LexicClinic)))
colnames(clcl) = names(LexicClinic)
LexicClinic <- lapply(LexicClinic, toupper)
colnames(clinic) <-gsub("[.]", "_",colnames(clinic))
LexicClinic <-  lapply(LexicClinic,function(x) gsub("[.]", "_",x))
if(file.exists(paste0(list.files.path$Project.Processes,"/Samples.CleanedProcess.txt"))){ file.remove(paste0(list.files.path$Project.Processes,"/Samples.CleanedProcess.txt"))}
cat("Samples.CleanedProcess" , file=paste0(list.files.path$Project.Processes,"/Samples.CleanedProcess.txt"),sep="\n",append = T)
cat("Raw.Clinic colnames Origin,Clean.Called" , file=paste0(list.files.path$Project.Processes,"/Samples.CleanedProcess.txt"),sep="\n",append = T)
for (i in 1:ncol(clinic)) {
pat <- toupper(colnames(clinic)[i])
col <- grep(paste("\\b",pat, "\\b",sep=""), LexicClinic)
cat(paste(pat,",", names(LexicClinic)[col]) , file=paste0(list.files.path$Project.Processes,"/Samples.CleanedProcess.txt"),sep="\n",append = T)
if(!length(col)==0){
clcl[,col] <- clinic[,i]
}
}
cc <- names(LexicClinic)
cc <- cc[!cc%in%("SamplesID")]
if(all(is.na(clcl$SamplesID))){
message("No SamplesID found in raw clinical data. Using PatientID instead")
clcl$SamplesID <- clcl$PatientsID
}
if(length(which(duplicated(clcl$SamplesID)))==0) {
clinic2 <-  clcl[,c("SamplesID", cc)]
clinic2 <- as.data.frame(clinic2)
clinic2[clinic2==""] <- NA
clinic2[clinic2=="NA"] <- NA
if(!all(str_detect(names(Metadata),name)==F)){
if(force.replace==F){stop("set force.replace==T to subset object.")}
message("Subsetting object.")
Metadata[[name]] <- clinic2
t= which(str_detect(names(Metadata),name))
attributes(Metadata)$Data.Type[t] <-  c("SamplesAnnot")
attributes(Metadata)$Export[t] <- c("Yes")
}else {
l <- length(Metadata)
Metadata[[l+1]] <- clinic2
names(Metadata)[l+1] <- name
attributes(Metadata)$Data.Type <-  c(attributes(Metadata)$Data.Type,"SamplesAnnot")
attributes(Metadata)$Export <- c(attributes(Metadata)$Export,"Yes")}
} else {
cl_rolled <- clcl %>%
# create groups by name
group_by(SamplesID) %>%
dplyr::summarise(across(everything(), ~paste0(unique(na.omit(.x)), collapse = ";")))
cl_rolled <- as.data.frame(cl_rolled)
cl_rolled <-  cl_rolled[,c("SamplesID", cc)]
cl_rolled[cl_rolled==""] <- NA
cl_rolled[cl_rolled=="NA"] <- NA
if(!all(str_detect(names(Metadata),name)==F)){
if(force.replace==F){stop("set force.replace==T to subset object.")}
message("Subsetting object.")
Metadata[[name]] <- cl_rolled
t= which(str_detect(names(Metadata),name))
attributes(Metadata)$Data.Type[t] <-  c("SamplesAnnot")
attributes(Metadata)$Export[t] <- c("Yes")
}else {
l <- length(Metadata)
Metadata[[l+1]] <- cl_rolled
names(Metadata)[l+1] <- name
attributes(Metadata)$Data.Type <-  c(attributes(Metadata)$Data.Type,"SamplesAnnot")
attributes(Metadata)$Export <- c(attributes(Metadata)$Export,"Yes")}
}
file.show(paste0(list.files.path$Project.Processes,"/Samples.CleanedProcess.txt"))
}} else if(type=="Patients")
{
NBP <- which(attributes(Metadata)$Data.Type=="Clinic" & attributes(Metadata)$Export=="No")
if(ForceCleaning==F){
if(length(NBP)==0){stop("No Clinic found in Metadata object. Set ForceCleaning=T to force cleaning from SamplesAnnot")}
} else { if(length(NBP)==0){ NBP <- which(str_detect(attributes(Metadata)$Data.Type ,"SamplesAnnot") & attributes(Metadata)$Export=="No")    }}
if(NBP==which(names(Metadata)%in%ClinicToClean)){
clinic <- as.data.frame(Metadata[[NBP]])
if(all.col==T){
for (i in colnames(Metadata$Clinic)){
if (!i %in% names(PatientLexic)){PatientLexic <- AddKeyLexic(lexic = PatientLexic, Param = c(i) ) }
}
LexicClinic <- PatientLexic
}else {  LexicClinic <- PatientLexic}
clcl <-  data.frame(matrix(nrow = nrow(clinic), ncol = length(LexicClinic)))
colnames(clcl) = names(LexicClinic)
LexicClinic <- lapply(LexicClinic, toupper)
colnames(clinic) <-gsub("[.]", "_",colnames(clinic))
LexicClinic <-  lapply(LexicClinic,function(x) gsub("[.]", "_",x))
if(file.exists(paste0(list.files.path$Project.Processes,"/Patients.CleanedProcess.txt"))){ file.remove(paste0(list.files.path$Project.Processes,"/Patients.CleanedProcess.txt"))}
cat("Patients.CleanedProcess" , file=paste0(list.files.path$Project.Processes,"/Patients.CleanedProcess.txt"),sep="\n",append = T)
cat("Raw.Clinic colnames Origin,Clean.Called" , file=paste0(list.files.path$Project.Processes,"/Patients.CleanedProcess.txt"),sep="\n",append = T)
for (i in 1:ncol(clinic)) {
pat <- toupper(colnames(clinic)[i])
col <- grep(paste("\\b",pat, "\\b",sep=""), LexicClinic)
cat(paste(pat,",", names(LexicClinic)[col]) , file=paste0(list.files.path$Project.Processes,"/Patients.CleanedProcess.txt"),sep="\n",append = T)
if(!length(col)==0){
clcl[,col] <- clinic[,i]
}
}
cc <- names(LexicClinic)
cc <- cc[!cc%in%("PatientsID")]
if(all(is.na(clcl$PatientsID))){
message("No PatientsID found in raw clinical data. Using PatientID instead")
clcl$PatientsID <- clcl$SamplesID
}
if(length(which(duplicated(clcl$PatientsID)))==0) {
clinic2 <-  clcl[,c("PatientsID", cc)]
clinic2 <- as.data.frame(clinic2)
clinic2[clinic2==""] <- NA
clinic2[clinic2=="NA"] <- NA
if(!all(str_detect(names(Metadata),name)==F)){
if(force.replace==F){stop("set force.replace==T to subset object.")}
message("Subsetting object.")
Metadata[[name]] <- clinic2
t= which(str_detect(names(Metadata),name))
attributes(Metadata)$Data.Type[t] <-  c("Clinic")
attributes(Metadata)$Export[t] <- c("Yes")
}else {
l <- length(Metadata)
Metadata[[l+1]] <- clinic2
names(Metadata)[l+1] <- name
attributes(Metadata)$Data.Type <-  c(attributes(Metadata)$Data.Type,"Clinic")
attributes(Metadata)$Export <- c(attributes(Metadata)$Export,"Yes")}
} else {
cl_rolled <- clcl %>%
# create groups by name
group_by(PatientsID) %>%
dplyr::summarise(across(everything(), ~paste0(unique(na.omit(.x)), collapse = ";")))
isNA <- which(is.na( cl_rolled$PatientsID))
if(length(isNA)>0){ cl_rolled <- as.data.frame(cl_rolled[-isNA,])  }
cl_rolled <- as.data.frame(cl_rolled)
cl_rolled <-  cl_rolled[,c("PatientsID", cc)]
cl_rolled[cl_rolled==""] <- NA
cl_rolled[cl_rolled=="NA"] <- NA
if(!all(str_detect(names(Metadata),name)==F)){
if(force.replace==F){stop("set force.replace==T to subset object.")}
message("Subsetting object.")
Metadata[[name]] <- cl_rolled
t= which(str_detect(names(Metadata),name))
attributes(Metadata)$Data.Type[t] <-  c("Clinic")
attributes(Metadata)$Export[t] <- c("Yes")
}else {
l <- length(Metadata)
Metadata[[l+1]] <- cl_rolled
names(Metadata)[l+1] <- name
attributes(Metadata)$Data.Type <-  c(attributes(Metadata)$Data.Type,"Clinic")
attributes(Metadata)$Export <- c(attributes(Metadata)$Export,"Yes")}
}
file.show(paste0(list.files.path$Project.Processes,"/Patients.CleanedProcess.txt"))
}} else {
stop("Choose type = c('Samples', 'Patients')")}
return(Metadata)
}
names(Meta)
Meta <- CleaningClinic(Metadata = Meta,
type = "Sample",
ClinicToClean = "Pheno",
name ="Pheno.cleaned" ,
list.files.path = list.files.path,
project = project,
ForceCleaning = T,
all.col = T)#la all.col TRUE rajoute toutes les colonne du clinic
Meta <- CleaningClinic(Metadata = Meta,
type = "Samples",
ClinicToClean = "Pheno",
name ="Pheno.cleaned" ,
list.files.path = list.files.path,
project = project,
ForceCleaning = T,
all.col = T)#la all.col TRUE rajoute toutes les colonne du clinic
View(Meta)
Meta <- CleaningClinic(Metadata = Meta,
type = "Samples",
ClinicToClean = "Pheno",
name ="Pheno.cleaned" ,
list.files.path = list.files.path,
project = project,
ForceCleaning = F,
all.col = T)#la all.col TRUE rajoute toutes les colonne du clinic
attributes(Meta)
which(attributes(Meta)$Data.Type=="SamplesAnnot" & attributes(Meta)$Export=="No")
which(names(Meta)%in%"Pheno")
#' @param project project
#' @param ForceCleaning If TRUE, Force a cleaning method from Samples.clinical data into Patient.clinical data and vice versa.
#' @param force.replace set as F. T : replace an already object with the same name
#' @param all.col default F, if T, copy all column from clinic.
#' @importFrom utils menu
#' @import dplyr
#' @return a data frame of Samples pheno or patients clinical data. If Sample ID and Patients ID are the sames, so Samples.pheno and Patient_clinic are the same data frame
#' @export
#'
#' @examples "none"
CleaningClinic <- function(Metadata,
ClinicToClean = NULL,
name = NULL,
type = c("Samples", "Patients"),
list.files.path,
project,
ForceCleaning = F,
force.replace = F,
all.col = F){
#Force.Replace et detected si name déjà existant à faire.
if(is.null(ClinicToClean)){stop("ClinicToClean must be a character")}
if(!inherits(ClinicToClean,what ="character" )){ stop("ClinicToClean must be a character")}
if(is.null(name)){stop("Name must be a character")}
if(!inherits(name,what ="character" )){ stop("Name must be a character")}
if(!ClinicToClean%in%names(Metadata)) {stop(paste0(ClinicToClean,"is not in Metaobject")) }
if(!all(str_detect(names(Metadata),name)==F)){
message("An Object with the same name already exist in MetaObject")
if(force.replace==F){stop("set force.replace==T to subset object.")}}
if(type=="Samples"){
NBS <- which(attributes(Metadata)$Data.Type=="SamplesAnnot" & attributes(Metadata)$Export=="No")
if(ForceCleaning==F){
if(length(NBS)==0){stop("No SamplesAnnot found in Metadata object. Set ForceCleaning=T to force cleaning from Clinic")}
} else {  if(length(NBS)==0){NBS <- which(str_detect(attributes(Metadata)$Data.Type ,"Clinic") & attributes(Metadata)$Export=="No")    }}
if(NBS==which(names(Metadata)%in%ClinicToClean)){
clinic <- as.data.frame(Metadata[[NBS]])
if(all.col==T){
for (i in colnames(Metadata$Clinic)){
if (!i %in% names(SamplesLexic)){SamplesLexic <- AddKeyLexic(lexic = SamplesLexic, Param = c(i) ) }
}
LexicClinic=SamplesLexic
}else {  LexicClinic <- SamplesLexic }
clcl <-  data.frame(matrix(nrow = nrow(clinic), ncol = length(LexicClinic)))
colnames(clcl) = names(LexicClinic)
LexicClinic <- lapply(LexicClinic, toupper)
colnames(clinic) <-gsub("[.]", "_",colnames(clinic))
LexicClinic <-  lapply(LexicClinic,function(x) gsub("[.]", "_",x))
if(file.exists(paste0(list.files.path$Project.Processes,"/Samples.CleanedProcess.txt"))){ file.remove(paste0(list.files.path$Project.Processes,"/Samples.CleanedProcess.txt"))}
cat("Samples.CleanedProcess" , file=paste0(list.files.path$Project.Processes,"/Samples.CleanedProcess.txt"),sep="\n",append = T)
cat("Raw.Clinic colnames Origin,Clean.Called" , file=paste0(list.files.path$Project.Processes,"/Samples.CleanedProcess.txt"),sep="\n",append = T)
for (i in 1:ncol(clinic)) {
pat <- toupper(colnames(clinic)[i])
col <- grep(paste("\\b",pat, "\\b",sep=""), LexicClinic)
cat(paste(pat,",", names(LexicClinic)[col]) , file=paste0(list.files.path$Project.Processes,"/Samples.CleanedProcess.txt"),sep="\n",append = T)
if(!length(col)==0){
clcl[,col] <- clinic[,i]
}
}
cc <- names(LexicClinic)
cc <- cc[!cc%in%("SamplesID")]
if(all(is.na(clcl$SamplesID))){
message("No SamplesID found in raw clinical data. Using PatientID instead")
clcl$SamplesID <- clcl$PatientsID
}
if(length(which(duplicated(clcl$SamplesID)))==0) {
clinic2 <-  clcl[,c("SamplesID", cc)]
clinic2 <- as.data.frame(clinic2)
clinic2[clinic2==""] <- NA
clinic2[clinic2=="NA"] <- NA
if(!all(str_detect(names(Metadata),name)==F)){
if(force.replace==F){stop("set force.replace==T to subset object.")}
message("Subsetting object.")
Metadata[[name]] <- clinic2
t= which(str_detect(names(Metadata),name))
attributes(Metadata)$Data.Type[t] <-  c("SamplesAnnot")
attributes(Metadata)$Export[t] <- c("Yes")
}else {
l <- length(Metadata)
Metadata[[l+1]] <- clinic2
names(Metadata)[l+1] <- name
attributes(Metadata)$Data.Type <-  c(attributes(Metadata)$Data.Type,"SamplesAnnot")
attributes(Metadata)$Export <- c(attributes(Metadata)$Export,"Yes")}
} else {
cl_rolled <- clcl %>%
# create groups by name
group_by(SamplesID) %>%
dplyr::summarise(across(everything(), ~paste0(unique(na.omit(.x)), collapse = ";")))
cl_rolled <- as.data.frame(cl_rolled)
cl_rolled <-  cl_rolled[,c("SamplesID", cc)]
cl_rolled[cl_rolled==""] <- NA
cl_rolled[cl_rolled=="NA"] <- NA
if(!all(str_detect(names(Metadata),name)==F)){
if(force.replace==F){stop("set force.replace==T to subset object.")}
message("Subsetting object.")
Metadata[[name]] <- cl_rolled
t= which(str_detect(names(Metadata),name))
attributes(Metadata)$Data.Type[t] <-  c("SamplesAnnot")
attributes(Metadata)$Export[t] <- c("Yes")
}else {
l <- length(Metadata)
Metadata[[l+1]] <- cl_rolled
names(Metadata)[l+1] <- name
attributes(Metadata)$Data.Type <-  c(attributes(Metadata)$Data.Type,"SamplesAnnot")
attributes(Metadata)$Export <- c(attributes(Metadata)$Export,"Yes")}
}
file.show(paste0(list.files.path$Project.Processes,"/Samples.CleanedProcess.txt"))
}} else if(type=="Patients")
{
NBP <- which(attributes(Metadata)$Data.Type=="Clinic" & attributes(Metadata)$Export=="No")
if(ForceCleaning==F){
if(length(NBP)==0){stop("No Clinic found in Metadata object. Set ForceCleaning=T to force cleaning from SamplesAnnot")}
} else { if(length(NBP)==0){ NBP <- which(str_detect(attributes(Metadata)$Data.Type ,"SamplesAnnot") & attributes(Metadata)$Export=="No")    }}
if(NBP==which(names(Metadata)%in%ClinicToClean)){
clinic <- as.data.frame(Metadata[[NBP]])
if(all.col==T){
for (i in colnames(Metadata$Clinic)){
if (!i %in% names(PatientLexic)){PatientLexic <- AddKeyLexic(lexic = PatientLexic, Param = c(i) ) }
}
LexicClinic <- PatientLexic
}else {  LexicClinic <- PatientLexic}
clcl <-  data.frame(matrix(nrow = nrow(clinic), ncol = length(LexicClinic)))
colnames(clcl) = names(LexicClinic)
LexicClinic <- lapply(LexicClinic, toupper)
colnames(clinic) <-gsub("[.]", "_",colnames(clinic))
LexicClinic <-  lapply(LexicClinic,function(x) gsub("[.]", "_",x))
if(file.exists(paste0(list.files.path$Project.Processes,"/Patients.CleanedProcess.txt"))){ file.remove(paste0(list.files.path$Project.Processes,"/Patients.CleanedProcess.txt"))}
cat("Patients.CleanedProcess" , file=paste0(list.files.path$Project.Processes,"/Patients.CleanedProcess.txt"),sep="\n",append = T)
cat("Raw.Clinic colnames Origin,Clean.Called" , file=paste0(list.files.path$Project.Processes,"/Patients.CleanedProcess.txt"),sep="\n",append = T)
for (i in 1:ncol(clinic)) {
pat <- toupper(colnames(clinic)[i])
col <- grep(paste("\\b",pat, "\\b",sep=""), LexicClinic)
cat(paste(pat,",", names(LexicClinic)[col]) , file=paste0(list.files.path$Project.Processes,"/Patients.CleanedProcess.txt"),sep="\n",append = T)
if(!length(col)==0){
clcl[,col] <- clinic[,i]
}
}
cc <- names(LexicClinic)
cc <- cc[!cc%in%("PatientsID")]
if(all(is.na(clcl$PatientsID))){
message("No PatientsID found in raw clinical data. Using PatientID instead")
clcl$PatientsID <- clcl$SamplesID
}
if(length(which(duplicated(clcl$PatientsID)))==0) {
clinic2 <-  clcl[,c("PatientsID", cc)]
clinic2 <- as.data.frame(clinic2)
clinic2[clinic2==""] <- NA
clinic2[clinic2=="NA"] <- NA
if(!all(str_detect(names(Metadata),name)==F)){
if(force.replace==F){stop("set force.replace==T to subset object.")}
message("Subsetting object.")
Metadata[[name]] <- clinic2
t= which(str_detect(names(Metadata),name))
attributes(Metadata)$Data.Type[t] <-  c("Clinic")
attributes(Metadata)$Export[t] <- c("Yes")
}else {
l <- length(Metadata)
Metadata[[l+1]] <- clinic2
names(Metadata)[l+1] <- name
attributes(Metadata)$Data.Type <-  c(attributes(Metadata)$Data.Type,"Clinic")
attributes(Metadata)$Export <- c(attributes(Metadata)$Export,"Yes")}
} else {
cl_rolled <- clcl %>%
# create groups by name
group_by(PatientsID) %>%
dplyr::summarise(across(everything(), ~paste0(unique(na.omit(.x)), collapse = ";")))
isNA <- which(is.na( cl_rolled$PatientsID))
if(length(isNA)>0){ cl_rolled <- as.data.frame(cl_rolled[-isNA,])  }
cl_rolled <- as.data.frame(cl_rolled)
cl_rolled <-  cl_rolled[,c("PatientsID", cc)]
cl_rolled[cl_rolled==""] <- NA
cl_rolled[cl_rolled=="NA"] <- NA
if(!all(str_detect(names(Metadata),name)==F)){
if(force.replace==F){stop("set force.replace==T to subset object.")}
message("Subsetting object.")
Metadata[[name]] <- cl_rolled
t= which(str_detect(names(Metadata),name))
attributes(Metadata)$Data.Type[t] <-  c("Clinic")
attributes(Metadata)$Export[t] <- c("Yes")
}else {
l <- length(Metadata)
Metadata[[l+1]] <- cl_rolled
names(Metadata)[l+1] <- name
attributes(Metadata)$Data.Type <-  c(attributes(Metadata)$Data.Type,"Clinic")
attributes(Metadata)$Export <- c(attributes(Metadata)$Export,"Yes")}
}
file.show(paste0(list.files.path$Project.Processes,"/Patients.CleanedProcess.txt"))
}} else {
stop("Choose type = c('Samples', 'Patients')")}
return(Metadata)
}
Meta <- CleaningClinic(Metadata = Meta,
type = "Samples",
ClinicToClean = "Pheno",
name ="Pheno.cleaned" ,
list.files.path = list.files.path,
project = project,
ForceCleaning = F,
all.col = T)#la all.col TRUE rajoute toutes les colonne du clinic
Meta <- CleaningClinic(Metadata = Meta,
type = "Samples",
ClinicToClean = "Pheno",
name ="Pheno.cleaned" ,
list.files.path = list.files.path,
project = project,
force.replace = T,
ForceCleaning = F,
all.col = T)#la all.col TRUE rajoute toutes les colonne du clinic
View(Meta)
Meta[["Pheno.cleaned"]]
Meta <- CleaningClinic(Metadata = Meta,
type = "Samples",
ClinicToClean = "Pheno",
name ="Pheno.cleaned" ,
list.files.path = list.files.path,
project = project,
force.replace = T,
ForceCleaning = T,
all.col = T)#la all.col TRUE rajoute toutes les colonne du clinic
Meta[["Pheno.cleaned"]]
Meta <- AddExpressionMatrixRNAseq(Metadata = NULL,
Export = T,# True pour Export
Raw.file.path = list.files.path$Project.RawData,
name.local.file ="PANC.rawcount.csv",
name = "Raw.count")
attributes(Meta) # attributes(Meta)$Data.type has the data type information for multipe functions
head(Meta$Raw.count.matrix[,1:5])
Meta$Raw.count.matrix[,1] <- NULL  # First colonne, geneSymbols drop off.
Meta <-AddExpressionMatrixRNAseq(Metadata = Meta,
Export = T,# True pour Export
Raw.file.path = list.files.path$Project.RawData,
name.local.file ="PANC.NormCount.csv",
name = "Normalized.count")
head(Meta$Normalized.count.matrix[,1:5])
Meta$Normalized.count.matrix[,1] <- NULL
all(colnames(Meta$Normalized.count.matrix)%in%colnames(Meta$Raw.count.matrix))
attributes(Meta)
CheckMeta(Meta)
###create LexicCLinic and SamplesOrPAtient objects to add or replace colnames of clinical data.
Meta = AddClinicFromFile(Metadata = Meta,
Raw.file.path = list.files.path$Project.RawData,
name.local.file = c( "PANC.samplesAnnotation.csv", "PANC.Clinic.all.csv"),
mergeBy = "id_cit", #mandatory if name.local.file >1 string
join = "full_join", #mandatory if name.local.file >1 string
name = "Pheno",
type = "Samples",
Export =  F
)
# Meta = AddClinicFromObject(Metadata = Meta,
#                            object = Clinic,
#                            name = "Pheno",
#                            SamplesFilter =F ,
#                            type = "Patients",
#                            Export ="Yes",
#                            force.replace = F)
Meta$Pheno[Meta$Pheno=="#NA"] = NA
Meta$Pheno[Meta$Pheno=="NA"] = NA
Meta$Pheno[Meta$Pheno=="xx"] = NA
Meta$Pheno = Meta$Pheno[!is.na(Meta$Pheno$id_cit),]
Meta$Pheno= as.data.frame(Meta$Pheno)
rownames(Meta$Pheno) = Meta$Pheno$id_cit
Meta$Pheno = Meta$Pheno[Meta$Pheno$id_cit%in%colnames(Meta$Normalized.count.matrix),]
attributes(Meta)
CheckMeta(Meta)
str(Meta$Pheno)
Meta$Pheno = Charac.to.Num(Meta$Pheno)
str(Meta$Pheno)
Meta <- CleaningClinic(Metadata = Meta,
type = "Samples",
ClinicToClean = "Pheno",
name ="Pheno.cleaned" ,
list.files.path = list.files.path,
project = project,
force.replace = F,
ForceCleaning = T,
all.col = T)#la all.col TRUE rajoute toutes les colonne du clinic
View(Meta)
Meta[["Pheno.cleaned"]]
View(SamplesLexic)
View(PatientLexic)
